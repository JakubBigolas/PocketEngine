from modules.pe.domain.app_context import AppContext
from .args_handler_abstract import ArgsHandlerAbstract
from ....data.execution_context_data import ExecutionContextData


class OptionHelpHandler(ArgsHandlerAbstract):

    def handle(self, app_context: AppContext, context_data: ExecutionContextData, args: list):
        print("PocketEngine (pe)")
        print()
        print("Main PocketEngine purpose is to store and invoke multiple commands with configured arguments")
        print("context as simple as it can be in one place!")
        print("It is useful if you very often need to run same commands with different parametrization.")
        print("Write your command, replace parameters with configurable arguments and save it using name familiar for you.")
        print("Now you can set parameters and invoke your command simple and quick without any script manual management.")
        print()
        print("Usage: pe [options...] [context arguments...] - [command] [command parametrization...] ...")
        print("Usage: pe [options...] [arguments...] -- [stored command] [context arguments...] ...")
        print("")
        print("Options:")
        print("")
        self.print_arg_value('set'              , 'enable setting arguments cache sequention')
        self.print_arg_value(''                 , 'NOTICE: at least there will be only one value for key')
        self.print_arg_value('add'              , 'enable adding arguments cache sequention (enabled by default)')
        self.print_arg_value(''                 , 'allow to add the same key in cache multiple times')
        self.print_arg_value('unset'            , 'start removing arguments cache sequention by key name (all occurrences of key)')
        self.print_arg_value('clear'            , 'remove all arguments from cache')
        self.print_arg_value('verbose'          , 'print each execution command before run')
        self.print_arg_value('dev-mode'         , 'development mode allow to see what engine will produce and run, without real execution')
        self.print_arg_value(''                 , 'enables verbose mode by default')
        self.print_arg_value('context-path'     , 'return path of store directory')
        self.print_arg_value('help'             , 'print this help info and exit')
        self.print_arg_value('version'          , 'print version info and exit')
        print("")
        self.print_arg_value('----------------' , 'Arguments context management:')
        print("")
        self.print_arg_value('cleanup'          , 'remove unnamed and default context and exit')
        print("")
        self.print_arg_value('contexts'         , 'print simple list of all saved context names and exit')
        self.print_arg_value('context-list'     , 'print simple list of all saved contexts with arguments and exit')
        self.print_arg_value('context-list/*'   , 'print filtered extended list of saved contexts with arguments and exit')
        self.print_arg_value('context-rm/*  '   , 'remove named arguments context and exit')
        self.print_arg_value('context'          , 'load saved unnamed context arguments to cache')
        self.print_arg_value('context/*'        , 'load saved named context arguments to cache')
        self.print_arg_value('c/*'              , 'short version of context/*')
        print("")
        self.print_arg_value('default'          , 'save all arguments cache as default context  (it is performed just before first execution)')
        print("")
        self.print_arg_value('store'            , 'save all arguments cache as unnamed context  (it is performed just before first execution)')
        self.print_arg_value('store/*'          , 'save all arguments cache as specific context (it is performed just before first execution)')
        self.print_arg_value('s/*'              , 'short version of store/*')
        print("")
        self.print_arg_value('----------------' , 'Executions management:')
        print("")
        self.print_arg_value('save-as *'        , 'save whole execution chain as specified name')
        self.print_arg_value('execs'            , 'print all stored execution names and exit')
        self.print_arg_value('exec-list'        , 'print all stored executions with simple content and exit')
        self.print_arg_value('exec-list/*'      , 'print filtered stored executions with extended content and exit')
        self.print_arg_value('exec-rm/*'        , 'remove named execution and exit')
        print("")
        self.print_arg_value('----------------' , 'Execution chain:')
        print("")
        self.print_arg_value('-'                , 'start new command execution chain')
        self.print_arg_value('--'               , 'load execution chain by name')
        self.print_arg_value(''                 , 'execute with current arguments cache (verbose option is inherited)')
        self.print_arg_value(''                 , 'and additional param list passed after execution name')
        print("")
        print("Arguments:")
        print(" To set arguments just type them as space separated KEY VALUE pairs or KEY=VALUE pair or just KEY.")
        print(" If argument starts with character '-' it is always treated as KEY (even if there was key before).")
        print(" If KEY has character '=' then another argument will be treated as KEY too (even if it looks like value).")
        print(" NOTICE: if unset mode is enabled then everything is treated as key and if there is value associated with key it will be removed too.")
        print(" Each KEY, VALUE or execution element (except first element) will be wrapped in quotes excluding internal KEYs")
        print("")
        print("Command parametrization:")
        print("")
        print(' Selection form: get all arguments from context...')
        self.print_arg_value(" <<#@#>>", "and return")
        print("")
        print(' Selection form: find X in arguments context and...')
        self.print_arg_value("  <<#X#>>",                      "return", 34)
        self.print_arg_value("  <<#X?:OR_ELSE>>",              "return or if X not exists return OR_ELSE", 34)
        self.print_arg_value("  <<#X->REPLACEMENT#>>",         "replace it with REPLACEMENT and return", 34)
        self.print_arg_value("  <<#X->REPLACEMENT?:OR_ELSE>>", "replace it with REPLACEMENT and return or if X not exists return OR_ELSE", 34)
        print("")
        print('  Where ')
        print('   REPLACEMENT and OR_ELSE are just string or another selection form')
        print('   Where X is')
        self.print_arg_value("    key",        "just key")
        self.print_arg_value("    key[*]",     "value (concatenated values) for key")
        self.print_arg_value("    key[@]",     "count of values for key")
        self.print_arg_value("    key[index]", "value for key at specified index")
        self.print_arg_value("    !key",       "key or error if there is no key")
        self.print_arg_value("    !key[...]",  "key value or error if there is no key or value")
        print("")
        print(' Selection form: find values for key in arguments context and repeat internal section for each value')
        self.print_arg_value(" [[#each:key#]] repeatable content [[#each#]]", "")
        print("  Each loop add some additional arguments to context:")
        self.print_arg_value("   --each-item"  , "current item of loop"                               , 26)
        self.print_arg_value("   --each-index" , "current index of loop"                              , 26)
        self.print_arg_value("   --each-size"  , "count of all items of loop"                         , 26)
        self.print_arg_value("   --each-first" , "true for first otherwise non-included"              , 26)
        self.print_arg_value("   --each-last"  , "true for last element otherwise false non-included" , 26)
        print('  NOTICE: if loops are nested, each additional "loop argument" will be treated as array')
        print('          and these arguments are ordered beginning from most nested to first loop occurrence')
        exit(0)

    def print_arg_value(self, key: str, value: str, lenght = 18):
        print(("{0: <" + str(lenght) + "}{1}").format(key, value))



    def accepts(self, app_context: AppContext, context_data: ExecutionContextData, args: list) -> bool:
        arg = args[0]
        return arg and ( arg == "help" or arg == "--help" or arg == "-?" )
